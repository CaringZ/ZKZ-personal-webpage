import type { Project } from '@/lib/types'

export const hobbyProjects: Project[] = [
  {
    id: "hobby-1",
    title: "ArroEngine",
    description: "ArroEngine 是我作为一名非专业程序员，利用 AI 辅助开发的一款跨平台自动化文件管理器。它拥有极其精美简洁的现代化界面，但在这层‘极简’的外衣下，藏着我对自己逻辑思维的极限挑战。为了追求极致的功能丰富度，我设计了‘文件’与‘文件夹’两套完全独立的处理逻辑。它不仅能批量重命名、归档，还支持复杂的撤销/重做（Undo/Redo）和历史回溯。这是一个正在不断进化的‘逻辑迷宫’，也是我验证‘AI + 审美 + 逻辑构建能力’的最佳试验场。",
    type: "hobby",
    technologies: ["Electron", "TypeScript", "React", "Vite", "Tailwind CSS"],
    year: "2025",
    status: "active",
    github: "#",
    hobby: {
      tagline: "用 AI 编织的“数字管家”：挑战逻辑极限的文件自动化引擎",
      motivation: "作为一个对代码一知半解的美术，我一直想挑战一下：能不能依靠 AI，做出一个逻辑极其复杂、但界面又必须符合我审美标准的桌面软件？我不想做一个简单的‘改名工具’，我想做一个功能强大的‘引擎’。我希望它能像处理艺术品一样处理我的文件——既要精准（逻辑严密），又要优雅（界面精美）。这个项目对我来说，不仅是开发工具，更是一场关于‘如何用自然语言指挥 AI 驾驭复杂逻辑’的深度实验。",
      features: [
        {
          title: "可视化规则编排",
          desc: "告别正则噩梦，采用“积木式”拖拽交互。支持无限层级的 AND/OR 逻辑嵌套，无论是简单的“移动图片”，还是复杂的“将所有大于 500MB 的 MP4 文件归档到按年份命名的文件夹中”，都能轻松搞定。",
          icon: "Layout"
        },
        {
          title: "独创“双轨”处理引擎",
          desc: "针对单文件精修和文件夹批处理设计了两套完全独立的逻辑。软件能根据当前选中的对象，自动切换 UI 布局与统计逻辑，确保操作的精准性。",
          icon: "Cpu"
        },
        {
          title: "时光机系统",
          desc: "所有的重命名、移动操作都记录在案。哪怕你误操作把一万个文件改错了名字，只需轻轻一点“撤销”，一切瞬间恢复如初。",
          icon: "History"
        },
        {
          title: "实时全景仪表盘",
          desc: "实时显示当前任务的处理进度、文件数量变化。在点击“执行”之前，通过差异对比视图直观展示每一个文件即将发生的变化，拒绝“盲盒式”操作。",
          icon: "Activity"
        }
      ],
      useCases: [
        {
          title: "设计师的“素材收集癖”救星",
          pain: "下载文件夹里堆满了 PSD、AI、JPG、Reference 图，找素材像大海捞针。",
          solution: "设置 ArroEngine 监听下载目录。一旦检测到 .psd，自动移动到 素材库/源文件；检测到 .jpg 且文件名包含 ref，自动归档到 素材库/参考图。"
        },
        {
          title: "摄影师的“原片整理”助理",
          pain: "每次外拍回来，几千张 DSC_0001.ARW 毫无意义，整理照片要花半天。",
          solution: "一键拖入 SD 卡目录，规则引擎自动提取 Exif 拍摄时间，将文件名批量清洗为 2024-11-25_上海_外滩_001.ARW，并按 年份/月份 自动创建文件夹归档。"
        },
        {
          title: "开发者的“自动中转站”",
          pain: "经常需要解压各种 GitHub 源码包、整理 Log 日志、归档旧版本 Build。",
          solution: "设定“自动解压”规则，监控特定文件夹，压缩包一落地即自动解压并重命名为项目标准格式，旧文件自动打标归档到 Backup 目录。"
        }
      ],
      devLog: [
        { status: "done", text: "Electron 主进程与渲染进程通信" },
        { status: "active", text: "规则引擎 (Rule Engine) 设计" },
        { status: "todo", text: "接入轻量级本地大模型 (Llama 3)" },
        { status: "todo", text: "集成离线 OCR 引擎" },
        { status: "todo", text: "智能文件 Agent 主动建议" }
      ],
      codeSnippet: {
        title: "File Watcher",
        code: "chokidar.watch(path).on('add', (path) => processFile(path));"
      }
    },
    insights: [
      {
        title: "挑战: “文件”与“文件夹”的逻辑博弈",
        content: "起因: “单文件模式”和“文件夹模式”统计逻辑完全不同，混搭时撤销/重做逻辑爆炸。思路: 将它们视为继承自同一基类的不同实体，在 UI 层做严格的上下文隔离。结果: 确保软件清楚知道处于哪种模式，避免逻辑串线。收获: 复杂逻辑必须有严格的状态管理和上下文隔离。"
      },
      {
        title: "挑战: 批量处理的“回溯陷阱”",
        content: "起因: 分批重命名时计数器意外重置，导致第二批文件覆盖了第一批。思路: 引入全局游标管理跨批次计数状态，并强制加入“预检查机制”。结果: 杜绝了覆盖事故。收获: 涉及文件 IO 的操作必须有防御性编程思维，预检查是最后一道防线。"
      },
      {
        title: "心得: AI 是手，逻辑是脑",
        content: "起因: AI 写代码很快，但处理复杂业务逻辑（如撤销栈）时容易晕。思路: 人来设计核心逻辑和状态流转，AI 负责实现具体函数。结果: 实现了复杂功能。收获: 写代码可以靠 AI，但“设计逻辑”只能靠人。"
      }
    ]
  },
  {
    id: "hobby-2",
    title: "AirShot",
    description: "AirShot (轻截) 是一款基于 Python (PyQt5) 开发的轻量级桌面截图自动化工具。它的设计哲学是‘零学习成本’与‘即用即走’。针对市面上截图工具的两极分化——微信/系统截图功能缺失（无延时截图、标注样式少），而 Snipaste/ShareX 等专业软件又过于复杂（参数多、上手难）——AirShot 在寻找那个完美的平衡点。它以极简的现代化 UI 呈现，却在后台集成了屏幕钉图、延时截图、富文本标注等核心刚需功能，旨在为用户提供一种无负担的高效视觉记录体验。",
    type: "hobby",
    technologies: ["Python", "PyQt5"],
    year: "2024",
    status: "active",
    github: "#",
    hobby: {
      tagline: "极简即生产力：填补“微信截图”与“专业软件”之间空白的视觉笔记引擎",
      motivation: "作为图像工作者，我每天都在使用截图工具，但我始终找不到顺手的：微信/QQ截图方便但功能弱，专业软件强大但太重。AirShot 的诞生就是为了解决这个痛点：我希望它像微信截图一样简单直观，学习成本极低；但当我有进阶需求时（比如钉图参考、延时捕捉弹出菜单、调整标注粗细颜色），它又能提供专业级的支持。在保证需求覆盖的同时，最大限度地减少操作步骤和认知负担。",
      features: [
        {
          title: "屏幕钉图 (Pin-to-Screen)",
          desc: "悬浮置顶：截图后点击“钉”按钮，图片即刻悬浮在屏幕最上层。无缝参考：完美解决“写代码时需要频繁切换窗口看设计稿/API文档”的痛点，支持缩放和移动，用完即关。",
          icon: "Layout"
        },
        {
          title: "极简而强大的标注套件",
          desc: "拒绝千篇一律。提供多档线条粗细、字号大小以及精心调配的预设色盘。支持智能序号标记、隐私马赛克及矢量非破坏性编辑。",
          icon: "Edit"
        },
        {
          title: "智能延时截图",
          desc: "支持 1s/3s/5s/7s 延时截图，给你充足的时间打开菜单，从容捕捉稍纵即逝的右键菜单或悬停提示。",
          icon: "Clock"
        },
        {
          title: "极致性能",
          desc: "异步烘焙引擎确保即使在图上画了上千笔标注，界面依然丝般顺滑。全局热键一键唤起，无启动延迟。",
          icon: "Zap"
        }
      ],
      useCases: [
        {
          title: "零门槛的快速分享",
          pain: "给稍微有点需求但又不想花太多时间学习新软件的用户推荐截图软件。",
          solution: "AirShot 的界面没有任何晦涩的术语。截取 -> 标注 -> 双击保存/复制。逻辑直观，无需学习，安装即用。"
        },
        {
          title: "重度用户的“极速流”",
          pain: "需要连续截取多张图时，每次都要经历繁琐的保存流程。",
          solution: "支持自定义保存路径与一键保存热键。截图后按下空格键，图片自动按时间戳命名并秒存到指定目录。"
        },
        {
          title: "捕捉“幽灵”菜单",
          pain: "想截取软件的下拉菜单，但一按截图键菜单就缩回去了。",
          solution: "开启“3秒延时”，点击开始，然后从容地打开下拉菜单，等待 AirShot 自动捕捉那一瞬间。"
        }
      ],
      devLog: [
        { status: "done", text: "实现了全局热键监听 (Global Hotkey)" },
        { status: "done", text: "完成了截图区域选择算法" },
        { status: "active", text: "滚动截图 (Scroll Capture): 自动滚动网页拼接长图" },
        { status: "todo", text: "固定位置截图 (Fixed Region Capture): 一键重复截取同一区域" },
        { status: "todo", text: "一键分享 (One-click Sharing): 打通微信/QQ接口" },
        { status: "todo", text: "添加 OCR 文字识别功能" }
      ],
      codeSnippet: {
        title: "Global Hotkey Hook",
        code: "keyboard.add_hotkey('ctrl+alt+a', self.start_capture)"
      }
    },
    insights: [
      {
        title: "挑战: 极简与功能的博弈",
        content: "问题: 如何把众多功能塞进极简工具栏？解决: 采用‘上下文感知’设计。只有当选择特定工具时，相关选项才会出现。这种‘按需显示’的交互逻辑，让界面始终保持清爽。"
      },
      {
        title: "挑战: Win32 窗口管理的深坑",
        content: "问题: 钉图置顶且不抢占焦点在 Windows 上不稳定。解决: 直接调用 User32 API SetWindowPos 精确控制窗口层级，确保工具栏和钉图始终悬浮在最上层。"
      },
      {
        title: "心得: 做减法的艺术",
        content: "在这个项目中，我学到的最大教训是：克制。每一个新增的按钮都要经过深思熟虑。如果不是高频使用，就把它藏起来或者砍掉。"
      },
      {
        title: "心得: 用户体验 > 技术堆叠",
        content: "用户不关心你用了什么异步线程，他们只关心流畅度和启动速度。流畅度、启动速度、交互逻辑，这些才是产品的灵魂。"
      }
    ]
  },
  {
    id: "hobby-3",
    title: "Background Removal",
    description: "这款背景去除工具是为那些厌倦了在线抠图服务（收费昂贵、限制数量、上传隐私风险）的专业用户量身打造的。它基于先进的 Transformer (DETR) 深度学习模型，完全运行在本地 GPU/CPU 上。它不仅仅是一个脚本，而是一个拥有现代化深色 UI 的完整桌面应用。从单张图片的精细对比预览，到成百上千张素材的无人值守批量处理，它在‘易用性’与‘工业级效率’之间找到了完美的平衡。无需联网，无需付费，你的显卡就是最强的生产力。",
    type: "hobby",
    technologies: ["Python", "PyQt5", "Rembg", "ONNX Runtime", "PIL"],
    year: "2024",
    status: "completed",
    github: "#",
    hobby: {
      tagline: "本地算力的胜利：零隐私泄露、无限批量处理的 AI 抠图工作站",
      motivation: "作为一名经常需要处理素材的美术工作者，我发现市面上的解决方案都有明显的短板：在线工具效果好但收费贵且有隐私隐患；PS 动作批量处理不够灵活；开源脚本往往只有命令行界面。我开发这个工具的初衷很简单：我想要一个‘免费、离线、可视化’的抠图神器。我希望它能像商业软件一样拥有丝滑的交互，同时又能像极客工具一样支持无限制的批量作业。",
      features: [
        {
          title: "本地 AI 引擎 (Local AI Engine)",
          desc: "隐私安全：所有计算都在本地完成，图片数据绝不上传云端，100% 保护商业机密。智能分割：集成 BiRefNet 前沿分割模型，精准识别主体与背景。",
          icon: "Cpu"
        },
        {
          title: "双模作业流 (Dual-Mode Workflow)",
          desc: "精修模式：拖拽图片即刻预览，配备专业的“对比滑块”实时查看差异。批处理模式：一键启动，自动遍历所有子文件夹，利用 GPU 显存实现极速吞吐。",
          icon: "Layers"
        },
        {
          title: "现代化深色 UI (Modern Dark UI)",
          desc: "沉浸体验：采用无边框窗口设计，配合自定义的标题栏和圆角控件。交互细节：带有平滑动画的 Toggle 开关、自定义样式的进度条。",
          icon: "Layout"
        },
        {
          title: "多样化输出 (Versatile Output)",
          desc: "支持生成带有 Alpha 通道的透明 PNG，或纯黑白的 Mask 蒙版（方便二次调整或训练数据集制作），也可同时输出两者。",
          icon: "Image"
        }
      ],
      useCases: [
        {
          title: "电商美工的“上新日”",
          pain: "双十一前夕，有500个 SKU 的产品图需要扣除背景做海报，PS 钢笔工具扣到手抽筋。",
          solution: "打开“批量处理模式”，指向摄影师给的原始图文件夹，点击开始。去喝杯咖啡，回来时500张透明底的产品图已经整齐地躺在输出目录里了。"
        },
        {
          title: "AI 模型训练师",
          pain: "需要制作 LoRA 或 ControlNet 的训练集，需要大量的高质量 Mask 蒙版。",
          solution: "选择“获取图像轮廓”模式，批量将数千张素材转换为二值化蒙版，极大地加速了数据集准备流程。"
        },
        {
          title: "UI/UX 设计师的日常",
          pain: "这种图标/人像素材需要快速去底看看效果，打开 PS 太慢。",
          solution: "保持软件常驻后台。直接把素材拖进窗口，秒出预览图。拖动滑块检查边缘，满意直接保存。"
        }
      ],
      devLog: [
        { status: "done", text: "集成 rembg 库进行背景去除" },
        { status: "done", text: "实现了批量处理队列" },
        { status: "done", text: "添加了轮廓描边算法" },
        { status: "done", text: "实现无边框窗口与自定义标题栏" },
        { status: "done", text: "优化内存管理，解决批量处理泄漏问题" }
      ],
      codeSnippet: {
        title: "Remove Background",
        code: "output = remove(input_image, alpha_matting=True)"
      }
    },
    insights: [
      {
        title: "挑战: 软件“假死”与我的“后台”执念",
        content: "起因: 只要一点“开始”，整个软件就彻底卡死。思路: AI 解释了“多线程”的概念，并帮我把繁重的计算任务扔到了后台。结果: 看着进度条丝滑地走动，窗口随意拖拽，那种掌控感真的很棒。"
      },
      {
        title: "挑战: 为了“好看”而自找的麻烦",
        content: "起因: 我坚持要用“无边框窗口”，结果没了标题栏窗口不能拖动。思路: 像教小朋友一样，一点点描述给 AI 听：“当鼠标在这个区域按下时，记下坐标...”。结果: 还原了原生窗口那种“跟手”的感觉，成就感满满。"
      },
      {
        title: "挑战: 消失的内存",
        content: "起因: 处理 5000 张产品图的时候，软件跑着跑着就突然消失了（内存泄漏）。思路: 在 AI 指导下加了几行“打扫卫生”的代码（手动 GC）。结果: 内存曲线变成了一条平稳的直线。"
      },
      {
        title: "心得: 不懂代码，也能做“架构师”",
        content: "以前我觉得编程是“天书”，但现在我发现，代码其实只是翻译。只要我脑子里的逻辑是清楚的——比如“图片进来怎么处理”、“出错该怎么办”——AI 就能帮我翻译成计算机听得懂的话。"
      },
      {
        title: "心得: 从“怕报错”到“找茬”",
        content: "刚开始看到红色的报错代码，我心跳都会加速。现在？看到报错我反而有点兴奋，因为这意味着我又发现了一个逻辑漏洞。把报错甩给 AI，看它一步步分析原因，感觉就像带了个技术大牛在身边手把手教我。"
      }
    ]
  },
  {
    id: "hobby-4",
    title: "Excel Data Compare",
    description: "Excel Data Compare 是一款基于 Python (PyQt5 + Pandas) 开发的高性能桌面数据对比工具。它的核心理念是‘索引对齐’与‘智能清洗’。针对传统人工核对的低效和 Excel 公式对比的局限，本工具提供了一种工程化的解决方案。它不依赖行号，而是通过用户指定的‘唯一索引列’（如身份证号、SKU）将两份表格的数据逻辑对齐，自动清洗格式差异，并生成精确到单元格的差异报告，让数据变更一目了然。",
    type: "hobby",
    technologies: ["Python", "PyQt5", "Pandas", "OpenPyXL"],
    year: "2024",
    status: "completed",
    github: "#",
    hobby: {
      tagline: "告别 VLOOKUP：专为数据工作者打造的智能、精准、可视化的 Excel 差异分析神器",
      motivation: "作为一个曾经经常处理表格数据的人，我深知‘版本迭代’带来的痛苦：行列错位的噩梦、格式陷阱、VLOOKUP 的繁琐。Excel Data Compare 的诞生就是为了终结这些痛点：我需要一个工具，它能像数据库一样思考——只认 ID 不认行号；它能像老会计一样细心——自动抹平‘1.0’和‘1’的差异；它还要足够简单——点两下鼠标，差异报告自动生成。",
      features: [
        {
          title: "基于索引的逻辑对齐",
          desc: "无视乱序：无论数据行如何打乱、新增或删除，只要索引一致，就能精准匹配对比。自动排重：智能检测并提示索引列中的重复值。",
          icon: "GitMerge"
        },
        {
          title: "智能数据清洗",
          desc: "格式归一化：自动处理数字与字符串的模糊匹配（如 '100' vs '100.00'）。容错处理：自动去除首尾空格、千分位逗号。",
          icon: "Sparkles"
        },
        {
          title: "灵活的列映射",
          desc: "同名自动匹配，异名手动关联。支持搜索与筛选，面对几百列的大宽表也能快速定位。",
          icon: "List"
        },
        {
          title: "极速启动与处理",
          desc: "懒加载技术实现秒开，仅在开始对比时加载 Pandas。仅导出有差异的行和列，生成清晰的‘差异明细表’。",
          icon: "Zap"
        },
        {
          title: "极简交互",
          desc: "一键提取表头，下拉式匹配，内置“自动匹配同名列”按钮，一键完成 90% 的配置工作。",
          icon: "MousePointer"
        }
      ],
      useCases: [
        {
          title: "电商运营的 SKU 价格核对",
          pain: "供应商发来新的价格表，几千个 SKU，顺序全乱了，只想知道哪些商品涨价了。",
          solution: "以‘SKU编码’为索引，自动匹配‘供货价’列。工具会直接输出所有价格变动的商品明细，涨跌一目了然。"
        },
        {
          title: "HR 的花名册更新",
          pain: "总部发来的新名单和本地名单对比，有人离职，有人新入职，还有人改了电话。",
          solution: "以‘身份证号’或‘工号’为索引，全选所有列进行对比。工具不仅能发现信息变更，还能通过未匹配的索引快速找出新增和减少的人员。"
        },
        {
          title: "财务报表的版本比对",
          pain: "财务系统导出的 V1 版和 V2 版报表，金额看起来一样，但总数对不上，不知道是哪一笔出了问题。",
          solution: "利用工具的‘智能清洗’功能，忽略格式差异，精准定位到那笔被修改了‘0.01’元的异常账目。"
        }
      ],
      devLog: [
        { status: "done", text: "Pandas 数据帧差异比对核心逻辑" },
        { status: "done", text: "PyQt5 界面布局设计" },
        { status: "done", text: "实现了差异结果的高亮显示" },
        { status: "done", text: "实现懒加载 (Lazy Import) 优化启动速度" },
        { status: "done", text: "开发数据归一化管道 (Normalization Pipeline)" }
      ],
      codeSnippet: {
        title: "Data Diff Logic",
        code: "df_diff = pd.concat([df1, df2]).drop_duplicates(keep=False)"
      }
    },
    insights: [
      {
        title: "挑战: 启动速度与依赖包的矛盾",
        content: "问题: Pandas 太重了，启动慢。解决: 实施了‘延迟加载’ (Lazy Import) 策略，启动时只加载轻量库，点击开始才加载 Pandas。结果: 换来了极佳的首屏体验。"
      },
      {
        title: "挑战: 数据类型的“千层套路”",
        content: "问题: Excel 里的数据类型是个黑洞（1 vs 1.0 vs '1'）。解决: 构建了一套‘归一化管道’，统一转字符串并清洗。结果: 只有经过这套‘整形手术’后依然不同的值，才会被判定为真正的差异。"
      },
      {
        title: "心得: 工具的本质是解决信任问题",
        content: "数据对比工具最怕的不是‘报错’，而是‘漏报’或‘误报’。一旦用户发现一次误判，信任就会崩塌。因此，在数据清洗和类型处理上花费的时间，远比写界面要多得多。"
      },
      {
        title: "心得: 交互要顺应直觉",
        content: "最开始我设计的是左右两个下拉框选列，效率很低。后来改为‘列表+搜索+自动匹配’的模式。好的工具应该让用户感觉不到‘操作’的存在。"
      }
    ]
  },
  {
    id: "hobby-5",

    title: "自动打卡小助手",
    description: "一个用 AI “聊”出来的轻量级自动打卡工具，解决了下班忘记打卡的烦恼。",
    type: "hobby",
    technologies: ["python", "QT5"],
    year: "2024",
    status: "completed",
    github: "#",
    hobby: {
      tagline: "AI 聊出来的“摸鱼”神器：解决下班忘打卡的小痛点",
      motivation: "纯粹为了解决自己下班老忘打卡的小麻烦。也是一次用 AI 快速生成实用小工具的练手，整个过程就像聊天一样轻松，没遇到什么大坑。",
      features: [
        { title: "开机自启", icon: "Zap", desc: "Start on Boot" },
        { title: "定时触发", icon: "History", desc: "Scheduled Trigger" },
        { title: "模拟点击", icon: "Activity", desc: "Auto Click" }
      ],
      useCases: [
        { title: "下班忘打卡", pain: "经常忙到忘记点打卡软件", solution: "设置定时任务，到点自动弹窗并模拟点击" },
        { title: "电脑重启后失效", pain: "重启后忘记重新打开软件", solution: "实现开机自启，无感运行" }
      ],
      devLog: [
        { status: "done", text: "第一次实现开机自启功能" },
        { status: "done", text: "调试注册表写入权限" },
        { status: "done", text: "优化托盘图标交互" }
      ],
      codeSnippet: {
        title: "Auto Click",
        code: "pyautogui.click(x=100, y=200)"
      }
    },
    insights: [
      {
        title: "第一次搞“开机自启”，被注册表吓一跳",
        content: "以前总觉得开机自启是黑客技术，问了 AI 才知道要改注册表。代码发过来我都不敢跑，硬是缠着 AI 把每一行代码都解释了一遍，确定没毒才敢试。测试的时候反复重启电脑，虽然笨，但最后看到软件自动跳出来的那一刻，感觉真不一样。收获: 不懂原理没关系，AI 能把原理掰碎了讲给你听。"
      },
      {
        title: "聊着天就把软件做完了",
        content: "这个软件真是“聊”出来的。我就像个甲方一样提需求：“要个倒计时”、“要能最小化到托盘”，AI 就像个不知疲倦的乙方，秒出代码。以前觉得写软件是“憋大招”，现在感觉像是搭积木。收获: 只要逻辑通顺，AI 就是最好的手替。"
      }
    ]
  },
]
